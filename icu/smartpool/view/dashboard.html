<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>网格订单统计面板</title>
    <style>
        :root {
            color-scheme: dark;
            font-family: "Segoe UI", Roboto, Arial, sans-serif;
            background-color: #0f1624;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 24px;
            background: #0f1624;
            color: #e0e6f1;
        }

        a {
            color: #64b5f6;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        header {
            display: flex;
            flex-wrap: wrap;
            align-items: baseline;
            gap: 12px 24px;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
            font-size: 28px;
            letter-spacing: 0.4px;
        }

        header .meta {
            display: flex;
            gap: 16px;
            font-size: 14px;
            color: #90a4c1;
        }

        .header-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-actions label {
            font-size: 14px;
            color: #90a4c1;
        }

        .header-actions select {
            appearance: none;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #1f2a48;
            background: #111b2d;
            color: #e0e6f1;
            font-size: 14px;
            min-width: 220px;
        }

        .header-actions select:focus {
            outline: none;
            border-color: #3d8bfd;
            box-shadow: 0 0 0 2px rgba(61, 139, 253, 0.25);
        }

        main {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: #111b2d;
            border: 1px solid #1f2a48;
            border-radius: 10px;
            padding: 16px 18px;
            box-shadow: 0 0 18px rgba(10, 14, 26, 0.45);
        }

        .asset-overview {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .asset-overview-header {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 16px;
            align-items: baseline;
            font-size: 13px;
            color: #8fa3bf;
        }

        .asset-overview-header strong {
            font-size: 15px;
            color: #e0e6f1;
        }

        .asset-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .asset-metric {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px 14px;
            border-radius: 8px;
            background: rgba(36, 45, 68, 0.55);
            border: 1px solid rgba(63, 81, 128, 0.45);
        }

        .asset-metric-label {
            font-size: 12px;
            letter-spacing: 0.6px;
            color: #8fa3bf;
            text-transform: uppercase;
        }

        .asset-metric-value {
            font-size: 18px;
            font-weight: 600;
            color: #e0e6f1;
        }

        .asset-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .asset-card {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 14px 16px;
            border-radius: 10px;
            background: rgba(27, 37, 59, 0.75);
            border: 1px solid rgba(47, 65, 102, 0.6);
        }

        .asset-card-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 10px;
        }

        .asset-card-title {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .asset-card-profit {
            font-size: 16px;
            font-weight: 600;
        }

        .asset-card-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px 12px;
        }

        .asset-card-metric {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .asset-card-metric-label {
            font-size: 11px;
            letter-spacing: 0.4px;
            color: #8fa3bf;
            text-transform: uppercase;
        }

        .asset-card-metric-value {
            font-size: 14px;
            font-weight: 600;
            color: #e0e6f1;
        }

        .asset-card-footer {
            font-size: 12px;
            color: #90a4c1;
        }

        .asset-overview-footer {
            font-size: 12px;
            color: #90a4c1;
        }

        h2 {
            margin: 0 0 12px;
            font-size: 18px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead {
            background: rgba(45, 66, 104, 0.55);
        }

        th,
        td {
            padding: 8px 10px;
            border-bottom: 1px solid #1f2a48;
            text-align: center;
            white-space: nowrap;
        }

        tbody tr:nth-child(odd) {
            background: rgba(20, 30, 48, 0.6);
        }

        tbody tr:hover {
            background: rgba(63, 81, 128, 0.35);
        }

        .text-right {
            text-align: center;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-buy {
            background: rgba(56, 142, 60, 0.28);
            color: #9cdf7c;
        }

        .badge-sell {
            background: rgba(244, 67, 54, 0.28);
            color: #ffa4a2;
        }

        .timeline-table td {
            white-space: nowrap;
        }

        .placeholder {
            margin: 0;
            color: #90a4c1;
        }

        .arbitrage-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }

        .arbitrage-table th,
        .arbitrage-table td {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(47, 65, 102, 0.6);
            white-space: nowrap;
            text-align: center;
        }

        .arbitrage-table .text-right {
            text-align: center;
        }

        .arbitrage-summary-row {
            cursor: pointer;
            background: rgba(20, 30, 48, 0.45);
            transition: background 0.2s, border 0.2s;
        }

        .arbitrage-summary-row:hover,
        .arbitrage-summary-row:focus-visible {
            background: rgba(40, 60, 96, 0.55);
        }

        .arbitrage-summary-row:focus-visible {
            outline: 2px solid rgba(61, 139, 253, 0.5);
            outline-offset: -2px;
        }

        .arbitrage-summary-row .arbitrage-id-cell {
            font-weight: 600;
            color: #e0e6f1;
        }

        .arbitrage-summary-row small {
            display: block;
            font-size: 11px;
            color: #8fa3bf;
        }

        .arbitrage-pagination {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            margin: 12px 4px 0;
        }

        .arbitrage-page-btn {
            padding: 4px 12px;
            border: 1px solid rgba(47, 65, 102, 0.6);
            border-radius: 6px;
            background: rgba(37, 51, 82, 0.85);
            color: #e0e6f1;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }

        .arbitrage-page-btn:hover:not(:disabled) {
            background: rgba(57, 81, 124, 0.9);
            border-color: rgba(91, 123, 177, 0.9);
            color: #f5f7fb;
        }

        .arbitrage-page-btn:disabled {
            cursor: not-allowed;
            opacity: 0.55;
        }

        .arbitrage-page-indicator {
            font-size: 13px;
            color: #8fa3bf;
        }

        .arbitrage-detail-row td {
            padding: 0;
            border-bottom: 1px solid rgba(47, 65, 102, 0.6);
            background: rgba(12, 18, 32, 0.75);
        }

        .section-indicator {
            margin: 0 0 12px;
            font-size: 13px;
            color: #8fa3bf;
        }

        .error {
            color: #ef9a9a;
        }

        .profit-positive {
            color: #9cdf7c;
        }

        .profit-negative {
            color: #ef9a9a;
        }

        .profit-neutral {
            color: #cfd8dc;
        }

        .task-block {
            border: 1px solid #1f2a48;
            border-radius: 8px;
            background: rgba(17, 27, 45, 0.65);
            margin-bottom: 12px;
        }

        .task-block summary {
            cursor: pointer;
            padding: 12px 14px;
            padding-right: 40px;
            outline: none;
            position: relative;
            display: block;
        }

        .task-block summary::after {
            content: '⌄';
            position: absolute;
            right: 18px;
            top: 50%;
            transform: translateY(-50%);
            color: #8fa3bf;
            transition: transform 0.2s;
        }

        .task-block[open] summary::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .task-block summary::-webkit-details-marker {
            display: none;
        }

        .task-block summary:focus-visible {
            box-shadow: 0 0 0 2px rgba(61, 139, 253, 0.4);
            border-radius: 8px 8px 0 0;
        }

        .arbitrage-detail {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .arbitrage-detail-legs {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .arbitrage-detail-rates {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 12px;
            color: #90a4c1;
        }

        .task-header {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .task-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .task-title {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .task-subtitle {
            margin: 2px 0 0;
            font-size: 13px;
            color: #8fa3bf;
            line-height: 1.4;
        }

        .task-chip-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px 10px;
        }

        .task-chip {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(27, 37, 59, 0.6);
            border: 1px solid rgba(63, 81, 128, 0.55);
            font-size: 12px;
            color: #b0c4de;
            letter-spacing: 0.3px;
        }

        .task-summary-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 14px 18px;
            padding: 14px 16px;
            background: rgba(22, 32, 54, 0.65);
            border: 1px solid rgba(47, 65, 102, 0.5);
            border-radius: 10px;
        }

        .task-summary-card {
            flex: 1 1 200px;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .task-summary-label {
            font-size: 12px;
            color: #8fa3bf;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .task-summary-value {
            font-size: 18px;
            font-weight: 600;
            color: #e0e6f1;
        }

        @media (min-width: 960px) {
            .task-header {
                flex-direction: row;
                align-items: flex-start;
                justify-content: space-between;
                gap: 24px;
            }

            .task-summary-panel {
                max-width: 60%;
            }
        }

        .task-title-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.4px;
            background: rgba(61, 139, 253, 0.25);
            color: #90caf9;
            text-transform: uppercase;
        }

        .status-running {
            background: rgba(56, 142, 60, 0.28);
            color: #9cdf7c;
        }

        .status-paused,
        .status-idle {
            background: rgba(255, 193, 7, 0.25);
            color: #ffe082;
        }

        .status-stopped,
        .status-finished {
            background: rgba(244, 67, 54, 0.28);
            color: #ffa4a2;
        }

        .status-error {
            background: rgba(236, 64, 122, 0.28);
            color: #f48fb1;
        }

        .status-unknown {
            background: rgba(100, 181, 246, 0.22);
            color: #bbdefb;
        }

        .grid-task-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .grid-task-chip {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid rgba(47, 65, 102, 0.6);
            background: rgba(27, 37, 59, 0.75);
            color: inherit;
            cursor: pointer;
            text-align: left;
            font: inherit;
            transition: border 0.2s, background 0.2s, transform 0.2s;
        }

        .grid-task-chip:hover {
            border-color: rgba(100, 181, 246, 0.7);
            background: rgba(33, 47, 75, 0.85);
        }

        .grid-task-chip.active {
            border-color: #3d8bfd;
            box-shadow: 0 0 16px rgba(61, 139, 253, 0.35);
            background: rgba(40, 60, 96, 0.9);
        }

        .grid-task-chip:focus-visible {
            outline: none;
            border-color: #3d8bfd;
            box-shadow: 0 0 0 2px rgba(61, 139, 253, 0.35);
        }

        .grid-chip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .grid-chip-title {
            font-size: 16px;
            font-weight: 600;
        }

        .grid-chip-line {
            font-size: 12px;
            color: #8fa3bf;
        }

        .grid-chip-profit {
            font-size: 13px;
            font-weight: 600;
        }

        .grid-task-chip.grid-task-chip--no-config .grid-chip-line {
            color: #b0bec5;
        }

        .grid-config {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .grid-config-section {
            background: rgba(20, 30, 48, 0.4);
            border: 1px solid rgba(47, 65, 102, 0.6);
            border-radius: 8px;
            padding: 12px;
        }

        .grid-config-title {
            margin: 0 0 8px;
            font-size: 13px;
            color: #8fa3bf;
            letter-spacing: 0.4px;
        }

        .grid-config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px 16px;
        }

        .grid-config-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .config-label {
            font-size: 12px;
            color: #8fa3bf;
        }

        .config-value {
            font-size: 14px;
            font-weight: 500;
            color: #e0e6f1;
        }

        .task-block-content {
            padding: 0 14px 14px;
        }

        .rate-line {
            font-size: 12px;
            color: #90a4c1;
        }

        .rate-line + .rate-line {
            margin-top: 2px;
        }

        .arbitrage-orders-table-wrapper {
            overflow-x: auto;
        }

        .arbitrage-orders-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            background: rgba(27, 37, 59, 0.55);
            border: 1px solid rgba(47, 65, 102, 0.6);
            border-radius: 8px;
            overflow: hidden;
        }

        .arbitrage-orders-table thead {
            background: rgba(13, 20, 36, 0.8);
        }

        .arbitrage-orders-table th,
        .arbitrage-orders-table td {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(47, 65, 102, 0.6);
            white-space: nowrap;
            text-align: center;
        }

        .arbitrage-orders-table th.text-right,
        .arbitrage-orders-table td.text-right {
            text-align: center;
        }

        .arbitrage-orders-table tbody tr:last-child td {
            border-bottom: none;
        }

        @media (max-width: 720px) {
            body {
                padding: 16px;
            }

            header h1 {
                font-size: 24px;
            }

            table {
                font-size: 13px;
            }
        }

        [data-field-key] {
            position: relative;
            transition: background-color 0.6s ease, box-shadow 0.6s ease, transform 0.6s ease, color 0.6s ease;
        }

        .data-field-highlight {
            background-color: rgba(255, 193, 7, 0.28) !important;
            box-shadow: 0 0 0 1px rgba(255, 193, 7, 0.55), 0 0 18px rgba(255, 193, 7, 0.35);
            transform: translateY(-1px);
        }

        .data-field-highlight::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: inherit;
            border: 1px solid rgba(255, 214, 64, 0.55);
            pointer-events: none;
        }

        tbody tr.timeline-row-highlight {
            background: rgba(255, 193, 7, 0.32) !important;
            box-shadow: inset 0 0 0 1px rgba(255, 193, 7, 0.5);
        }
    </style>
</head>
<body>
<header>
    <h1>网格任务数据面板</h1>
    <div class="meta">
        <span id="last-refresh">最后更新：-</span>
        <span><a href="/">返回分析平台</a></span>
    </div>
    <div class="header-actions">
        <label for="grid-task-selector">选择网格任务</label>
        <select id="grid-task-selector"></select>
    </div>
</header>
<main>
    <section class="card">
        <h2>网格任务概览</h2>
        <div class="selected-task-overview" id="selected-task-overview"></div>
        <p class="placeholder" hidden id="grid-task-empty">暂无网格任务。</p>
        <p class="section-indicator" id="task-filter-indicator">当前任务：-</p>
        <div id="task-hierarchy"></div>
        <p class="placeholder" hidden id="task-empty">暂无任务统计。</p>
    </section>
    <section class="card">
        <h2>最新成交</h2>
        <p class="section-indicator" id="timeline-filter-indicator">当前任务：-</p>
        <div class="table-wrapper">
            <table class="timeline-table">
                <thead>
                <tr>
                    <th>交易对</th>
                    <th>订单ID</th>
                    <th>方向</th>
                    <th class="text-right">成交数量</th>
                    <th class="text-right">成交价格</th>
                    <th class="text-right">成交金额</th>
                    <th class="text-right">手续费</th>
                    <th>Maker占比</th>
                    <th>状态</th>
                    <th>时间</th>
                    <th>网格批次</th>
                </tr>
                </thead>
                <tbody id="timeline-table"></tbody>
            </table>
            <p class="placeholder" hidden id="timeline-empty">暂无订单。</p>
        </div>
    </section>
    <section class="card">
        <h2>数据源</h2>
        <p class="placeholder" id="source-meta">正在加载订单数据...</p>
        <p class="placeholder error" hidden id="error-message"></p>
    </section>
</main>
<script>
    const dashboardState = {
        orders: [],
        tasks: [],
        gridTasks: [],
        selectedTaskId: null,
        fieldSnapshot: new Map(),
        isRefreshing: false,
        refreshTimerId: null,
        orderKeySnapshot: new Set(),
        lastNewOrderKeys: new Set(),
        expandedTaskBlocks: new Map(),
        expandedArbitrages: new Map(),
        arbitragePage: new Map()
    };

    const DEFAULT_DECIMALS = 4;
    const FEE_DECIMALS = 5;
    const ARBITRAGE_PAGE_SIZE = 5;

    const taskSelectorEl = document.getElementById('grid-task-selector');
    if (taskSelectorEl) {
        taskSelectorEl.addEventListener('change', event => {
            updateSelectedTaskId(event.target.value);
        });
    }

    async function loadOrders() {
        const res = await fetch('../grid/data/orders.json', {cache: 'no-store'});
        if (!res.ok) {
            throw new Error(`无法加载订单数据：${res.status} ${res.statusText}`);
        }
        return res.json();
    }

    async function loadGridTasks() {
        const res = await fetch('../grid/data/grid_tasks.json', {cache: 'no-store'});
        if (!res.ok) {
            throw new Error(`无法加载网格任务数据：${res.status} ${res.statusText}`);
        }
        return res.json();
    }

    function normalizeOrders(rawOrders) {
        return rawOrders.map(order => {
            const price = safeNumber(order.price);
            const quantity = safeNumber(order.origQty);
            const updateTime = safeNumber(order.updateTime);
            const txFee = safeNumber(order.txFee);
            const makerParticipation = parseMakerFeeRate(order.makerFeeRate);
            const makerFee = Number.isFinite(txFee) && makerParticipation !== null ? txFee * makerParticipation : 0;
            const takerFee = Number.isFinite(txFee) ? Math.max(txFee - makerFee, 0) : 0;
            const takerParticipation = makerParticipation !== null ? Math.max(1 - makerParticipation, 0) : null;
            return {
                ...order,
                price,
                quantity,
                notional: price * quantity,
                updateTime,
                txFee,
                makerFee,
                takerFee,
                makerParticipation,
                takerParticipation
            };
        }).filter(order => Number.isFinite(order.updateTime));
    }

    function toNumberOrNull(value) {
        if (value === undefined || value === null) {
            return null;
        }
        if (typeof value === 'string' && value.trim() === '') {
            return null;
        }
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
    }

    function normalizeGridTasks(rawTasks) {
        if (!Array.isArray(rawTasks)) {
            return [];
        }
        return rawTasks.map(task => {
            const runtime = task && typeof task === 'object' ? task.runtime || {} : {};
            const id = String(task?.id ?? task?.taskId ?? '未命名任务').trim() || '未命名任务';
            const status = task?.status ? String(task.status).toUpperCase() : 'UNKNOWN';
            return {
                id,
                baseAsset: task?.baseAsset ?? task?.baseAssert ?? '',
                quoteAsset: task?.quoteAsset ?? task?.quoteAssert ?? '',
                doubled: Boolean(task?.doubled),
                reversed: Boolean(task?.reversed),
                startPrice: toNumberOrNull(task?.startPrice),
                startBaseP: toNumberOrNull(task?.startBaseP),
                startQuoteP: toNumberOrNull(task?.startQuoteP),
                gridRate: toNumberOrNull(task?.gridRate),
                gridValue: toNumberOrNull(task?.gridValue),
                status,
                runtime: {
                    baseQty: toNumberOrNull(runtime.baseQty),
                    quoteQty: toNumberOrNull(runtime.quoteQty),
                    buyPrice: toNumberOrNull(runtime.buyPrice),
                    sellPrice: toNumberOrNull(runtime.sellPrice),
                    lastTradePrice: toNumberOrNull(runtime.lastTradePrice)
                }
            };
        });
    }

    function safeNumber(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num : 0;
    }

    function parseMakerFeeRate(value) {
        if (value === undefined || value === null || value === '') {
            return null;
        }
        if (typeof value === 'string') {
            const trimmed = value.trim();
            if (!trimmed) {
                return null;
            }
            const normalized = trimmed.endsWith('%') ? trimmed.slice(0, -1) : trimmed;
            const num = Number(normalized);
            if (Number.isFinite(num)) {
                return clampPercent(num);
            }
        } else {
            const num = Number(value);
            if (Number.isFinite(num)) {
                return clampPercent(num);
            }
        }
        return null;
    }

    function clampPercent(value) {
        const ratio = value > 1 ? value / 100 : value;
        if (!Number.isFinite(ratio)) {
            return null;
        }
        return Math.min(Math.max(ratio, 0), 1);
    }

    function computeRealizedMetrics(buyQty, sellQty, avgBuyPrice, avgSellPrice) {
        const matchedQty = Math.min(buyQty || 0, sellQty || 0);
        const hasBothSides = matchedQty > 0
            && Number.isFinite(avgBuyPrice)
            && Number.isFinite(avgSellPrice)
            && avgBuyPrice > 0
            && avgSellPrice > 0;
        const priceSpread = hasBothSides ? (avgSellPrice - avgBuyPrice) : 0;
        const realizedProfit = hasBothSides ? matchedQty * priceSpread : 0;
        return {
            matchedQty,
            priceSpread,
            realizedProfit
        };
    }

    function aggregateOrdersBySymbol(orders, side) {
        const map = new Map();
        (orders || []).forEach(order => {
            const symbol = order.symbol || 'UNKNOWN';
            if (!map.has(symbol)) {
                map.set(symbol, {
                    symbol,
                    side,
                    quantity: 0,
                    notional: 0,
                    totalFee: 0,
                    makerParticipationSum: 0,
                    makerParticipationCount: 0,
                    makerNotional: 0,
                    participationNotional: 0,
                    orderCount: 0,
                    earliest: Number.POSITIVE_INFINITY,
                    latest: Number.NEGATIVE_INFINITY,
                    orders: []
                });
            }
            const entry = map.get(symbol);
            const quantity = Number.isFinite(order.quantity) ? order.quantity : 0;
            const notional = Number.isFinite(order.notional) ? order.notional : 0;
            entry.quantity += quantity;
            entry.notional += notional;
            if (Number.isFinite(order.txFee)) {
                entry.totalFee += order.txFee;
            }
            if (Number.isFinite(order.makerParticipation)) {
                entry.makerParticipationSum += order.makerParticipation;
                entry.makerParticipationCount += 1;
                entry.participationNotional += notional;
                entry.makerNotional += notional * order.makerParticipation;
            }
            entry.orderCount += 1;
            if (Number.isFinite(order.updateTime)) {
                entry.earliest = Math.min(entry.earliest, order.updateTime);
                entry.latest = Math.max(entry.latest, order.updateTime);
            }
            entry.orders.push(order);
        });
        return Array.from(map.values()).map(entry => ({
            ...entry,
            avgPrice: entry.quantity ? entry.notional / entry.quantity : 0,
            avgMakerParticipation: entry.makerParticipationCount
                ? entry.makerParticipationSum / entry.makerParticipationCount
                : null,
            makerOrderRatio: entry.participationNotional
                ? entry.makerNotional / entry.participationNotional
                : null,
            earliest: Number.isFinite(entry.earliest) ? entry.earliest : NaN,
            latest: Number.isFinite(entry.latest) ? entry.latest : NaN
        }));
    }

    function buildArbitrageSymbolLegs(arbitrage) {
        const buyLegs = aggregateOrdersBySymbol(arbitrage.buyOrders || [], 'BUY');
        const sellLegs = aggregateOrdersBySymbol(arbitrage.sellOrders || [], 'SELL');
        return [...buyLegs, ...sellLegs].sort((a, b) => {
            if (a.symbol === b.symbol) {
                if (a.side === b.side) {
                    return 0;
                }
                return a.side.localeCompare(b.side);
            }
            return a.symbol.localeCompare(b.symbol);
        });
    }

    function buildTaskHierarchy(orders) {
        const tasksById = new Map();
        for (const order of orders) {
            const taskId = order.taskId || '未命名任务';
            if (!tasksById.has(taskId)) {
                tasksById.set(taskId, {
                    taskId,
                    symbolSet: new Set(),
                    symbolMap: new Map(),
                    arbitrages: new Map(),
                    totalOrders: 0,
                    buyCount: 0,
                    sellCount: 0,
                    buyNotional: 0,
                    sellNotional: 0,
                    totalFee: 0,
                    makerFee: 0,
                    takerFee: 0,
                    makerParticipationSum: 0,
                    makerParticipationCount: 0,
                    makerNotional: 0,
                    participationNotional: 0,
                    start: Number.POSITIVE_INFINITY,
                    end: -Infinity
                });
            }
            const task = tasksById.get(taskId);
            task.symbolSet.add(order.symbol);
            task.totalOrders += 1;
            task.start = Math.min(task.start, order.updateTime);
            task.end = Math.max(task.end, order.updateTime);
            if (order.side === 'BUY') {
                task.buyCount += 1;
                task.buyNotional += order.notional;
            } else if (order.side === 'SELL') {
                task.sellCount += 1;
                task.sellNotional += order.notional;
            }

            if (!task.symbolMap.has(order.symbol)) {
                task.symbolMap.set(order.symbol, {
                    symbol: order.symbol,
                    orderCount: 0,
                    buyQty: 0,
                    sellQty: 0,
                    buyNotional: 0,
                    sellNotional: 0,
                    fee: 0,
                    makerFee: 0,
                    takerFee: 0,
                    makerParticipationSum: 0,
                    makerParticipationCount: 0,
                    makerNotional: 0,
                    participationNotional: 0,
                    lastUpdate: -Infinity,
                    lastPrice: NaN
                });
            }
            const symbolStats = task.symbolMap.get(order.symbol);
            symbolStats.orderCount += 1;
            symbolStats.lastUpdate = Math.max(symbolStats.lastUpdate, order.updateTime);
            if (Number.isFinite(order.price)) {
                symbolStats.lastPrice = order.price;
            }
            if (order.side === 'BUY') {
                symbolStats.buyQty += order.quantity;
                symbolStats.buyNotional += order.notional;
            } else if (order.side === 'SELL') {
                symbolStats.sellQty += order.quantity;
                symbolStats.sellNotional += order.notional;
            }
            if (Number.isFinite(order.txFee)) {
                task.totalFee += order.txFee;
                symbolStats.fee += order.txFee;
            }
            if (Number.isFinite(order.makerFee)) {
                task.makerFee += order.makerFee;
                symbolStats.makerFee += order.makerFee;
            }
            if (Number.isFinite(order.takerFee)) {
                task.takerFee += order.takerFee;
                symbolStats.takerFee += order.takerFee;
            }
            const bindId = order.taskBindId || '未分组批次';
            if (!task.arbitrages.has(bindId)) {
                task.arbitrages.set(bindId, {
                    taskBindId: bindId,
                    synthPrice: safeNumber(order.synthPrice),
                    orders: [],
                    buyOrders: [],
                    sellOrders: [],
                    buyNotional: 0,
                    sellNotional: 0,
                    buyQty: 0,
                    sellQty: 0,
                    totalFee: 0,
                    makerFee: 0,
                    takerFee: 0,
                    makerParticipationSum: 0,
                    makerParticipationCount: 0,
                    makerNotional: 0,
                    participationNotional: 0,
                    start: Number.POSITIVE_INFINITY,
                    end: -Infinity
                });
            }
            const arbitrage = task.arbitrages.get(bindId);
            arbitrage.orders.push(order);
            arbitrage.start = Math.min(arbitrage.start, order.updateTime);
            arbitrage.end = Math.max(arbitrage.end, order.updateTime);
            if (!arbitrage.synthPrice && order.synthPrice) {
                arbitrage.synthPrice = safeNumber(order.synthPrice);
            }
            if (order.side === 'BUY') {
                arbitrage.buyOrders.push(order);
                arbitrage.buyNotional += order.notional;
                arbitrage.buyQty += order.quantity;
            } else if (order.side === 'SELL') {
                arbitrage.sellOrders.push(order);
                arbitrage.sellNotional += order.notional;
                arbitrage.sellQty += order.quantity;
            }
            if (Number.isFinite(order.txFee)) {
                arbitrage.totalFee += order.txFee;
            }
            if (Number.isFinite(order.makerFee)) {
                arbitrage.makerFee += order.makerFee;
            }
            if (Number.isFinite(order.takerFee)) {
                arbitrage.takerFee += order.takerFee;
            }
            if (Number.isFinite(order.makerParticipation)) {
                const makerPart = order.makerParticipation;
                const orderNotional = order.notional;
                const makerNotionalShare = orderNotional * makerPart;
                task.makerParticipationSum += makerPart;
                task.makerParticipationCount += 1;
                task.makerNotional += makerNotionalShare;
                task.participationNotional += orderNotional;
                symbolStats.makerParticipationSum += makerPart;
                symbolStats.makerParticipationCount += 1;
                symbolStats.makerNotional += makerNotionalShare;
                symbolStats.participationNotional += orderNotional;
                arbitrage.makerParticipationSum += makerPart;
                arbitrage.makerParticipationCount += 1;
                arbitrage.makerNotional += makerNotionalShare;
                arbitrage.participationNotional += orderNotional;
            }
        }

        return Array.from(tasksById.values())
            .map(task => {
                const arbitrages = Array.from(task.arbitrages.values())
                    .map(arbitrage => {
                        const avgBuyPrice = arbitrage.buyQty ? arbitrage.buyNotional / arbitrage.buyQty : 0;
                        const avgSellPrice = arbitrage.sellQty ? arbitrage.sellNotional / arbitrage.sellQty : 0;
                        const {matchedQty, priceSpread, realizedProfit} = computeRealizedMetrics(
                            arbitrage.buyQty,
                            arbitrage.sellQty,
                            avgBuyPrice,
                            avgSellPrice
                        );
                        const symbolLegs = buildArbitrageSymbolLegs(arbitrage);
                        return {
                            ...arbitrage,
                            profit: arbitrage.sellNotional - arbitrage.buyNotional,
                            status: determineArbitrageStatus(arbitrage),
                            avgBuyPrice,
                            avgSellPrice,
                            matchedQty,
                            priceSpread,
                            realizedProfit,
                            symbolLegs,
                            makerParticipation: arbitrage.makerParticipationCount
                                ? arbitrage.makerParticipationSum / arbitrage.makerParticipationCount
                                : null,
                            makerOrderRatio: arbitrage.participationNotional
                                ? arbitrage.makerNotional / arbitrage.participationNotional
                                : null
                        };
                    })
                    .sort((a, b) => b.end - a.end);
                const symbolStats = Array.from(task.symbolMap.values())
                    .map(symbol => {
                        const avgBuyPrice = symbol.buyQty ? symbol.buyNotional / symbol.buyQty : 0;
                        const avgSellPrice = symbol.sellQty ? symbol.sellNotional / symbol.sellQty : 0;
                        const {matchedQty, priceSpread, realizedProfit} = computeRealizedMetrics(
                            symbol.buyQty,
                            symbol.sellQty,
                            avgBuyPrice,
                            avgSellPrice
                        );
                        return {
                            ...symbol,
                            avgBuyPrice,
                            avgSellPrice,
                            profit: symbol.sellNotional - symbol.buyNotional,
                            priceSpread,
                            matchedQty,
                            realizedProfit,
                            openQty: symbol.buyQty - symbol.sellQty,
                            openNotional: symbol.buyNotional - symbol.sellNotional,
                            totalFee: symbol.fee,
                            makerFeeTotal: symbol.makerFee,
                            takerFeeTotal: symbol.takerFee,
                            makerParticipation: symbol.makerParticipationCount
                                ? symbol.makerParticipationSum / symbol.makerParticipationCount
                                : null,
                            makerOrderRatio: symbol.participationNotional
                                ? symbol.makerNotional / symbol.participationNotional
                                : null,
                            lastPrice: Number.isFinite(symbol.lastPrice) ? symbol.lastPrice : null
                        };
                    })
                    .sort((a, b) => a.symbol.localeCompare(b.symbol));
                const totalRealizedProfit = symbolStats.reduce((sum, item) => sum + item.realizedProfit, 0);
                const completedCount = arbitrages.filter(item => item.status === '已完成').length;
                const openCount = arbitrages.length - completedCount;
                const netExposureQty = symbolStats.reduce((sum, item) => sum + item.openQty, 0);
                const netExposureNotional = symbolStats.reduce((sum, item) => sum + item.openNotional, 0);
                const latestTrade = arbitrages.length ? arbitrages[0].end : (Number.isFinite(task.end) ? task.end : NaN);
                return {
                    taskId: task.taskId,
                    symbols: Array.from(task.symbolSet).sort(),
                    arbitrages,
                    arbitrageCount: arbitrages.length,
                    completedCount,
                    openCount,
                    totalOrders: task.totalOrders,
                    buyCount: task.buyCount,
                    sellCount: task.sellCount,
                    buyNotional: task.buyNotional,
                    sellNotional: task.sellNotional,
                    profit: task.sellNotional - task.buyNotional,
                    realizedProfit: totalRealizedProfit,
                    netExposureQty,
                    netExposureNotional,
                    symbolStats,
                    latestTrade,
                    totalFee: task.totalFee,
                    makerFee: task.makerFee,
                    takerFee: task.takerFee,
                    makerParticipation: task.makerParticipationCount
                        ? task.makerParticipationSum / task.makerParticipationCount
                        : null,
                    makerOrderRatio: task.participationNotional
                        ? task.makerNotional / task.participationNotional
                        : null,
                    makerParticipationSum: task.makerParticipationSum,
                    makerParticipationCount: task.makerParticipationCount,
                    makerNotional: task.makerNotional,
                    participationNotional: task.participationNotional,
                    start: Number.isFinite(task.start) ? task.start : NaN,
                    end: Number.isFinite(task.end) ? task.end : NaN
                };
            })
            .sort((a, b) => b.end - a.end);
    }

    function createEmptyTaskStats(gridTask) {
        const symbols = [];
        if (gridTask?.baseAsset) {
            symbols.push(String(gridTask.baseAsset));
        }
        if (gridTask?.quoteAsset) {
            symbols.push(String(gridTask.quoteAsset));
        }
        return {
            taskId: gridTask?.id ?? '未命名任务',
            symbols,
            arbitrages: [],
            arbitrageCount: 0,
            completedCount: 0,
            openCount: 0,
            totalOrders: 0,
            buyCount: 0,
            sellCount: 0,
            buyNotional: 0,
            sellNotional: 0,
            profit: 0,
            realizedProfit: 0,
            netExposureQty: 0,
            netExposureNotional: 0,
            symbolStats: [],
            latestTrade: NaN,
            totalFee: 0,
            makerFee: 0,
            takerFee: 0,
            makerParticipation: null,
            makerOrderRatio: null,
            makerParticipationSum: 0,
            makerParticipationCount: 0,
            makerNotional: 0,
            participationNotional: 0,
            start: NaN,
            end: NaN,
            averageCrossRate: null,
            averageBuyRate: null,
            averageSellRate: null,
            gridTask,
            hasOrders: false
        };
    }

    function createPlaceholderSymbolStats(symbol) {
        return {
            symbol,
            orderCount: 0,
            buyQty: 0,
            sellQty: 0,
            buyNotional: 0,
            sellNotional: 0,
            avgBuyPrice: 0,
            avgSellPrice: 0,
            profit: 0,
            priceSpread: 0,
            matchedQty: 0,
            realizedProfit: 0,
            openQty: 0,
            openNotional: 0,
            totalFee: 0,
            makerFeeTotal: 0,
            takerFeeTotal: 0,
            makerParticipation: null,
            makerOrderRatio: null,
            lastUpdate: NaN,
            lastPrice: null
        };
    }

    function composeAssetStats(symbolStats, gridTask) {
        const statsArray = Array.isArray(symbolStats) ? symbolStats : [];
        const statsMap = new Map(statsArray.map(stat => [stat.symbol, stat]));
        const desiredOrder = [];
        if (gridTask?.baseAsset) {
            desiredOrder.push(String(gridTask.baseAsset));
        }
        if (gridTask?.quoteAsset && gridTask.quoteAsset !== gridTask.baseAsset) {
            desiredOrder.push(String(gridTask.quoteAsset));
        }
        const seen = new Set();
        const ordered = [];
        desiredOrder.forEach(symbol => {
            if (!symbol || seen.has(symbol)) {
                return;
            }
            const stats = statsMap.get(symbol);
            ordered.push(stats ? {...stats} : createPlaceholderSymbolStats(symbol));
            seen.add(symbol);
        });
        statsArray.forEach(stat => {
            if (seen.has(stat.symbol)) {
                return;
            }
            ordered.push({...stat});
            seen.add(stat.symbol);
        });
        return ordered;
    }

    function findLegBySymbol(legs, symbol) {
        if (!symbol || !Array.isArray(legs)) {
            return null;
        }
        const normalized = String(symbol).toUpperCase();
        return legs.find(leg => String(leg.symbol).toUpperCase() === normalized) || null;
    }

    function enhanceArbitrageWithGrid(arbitrage, gridTask) {
        const legs = Array.isArray(arbitrage.symbolLegs) ? arbitrage.symbolLegs : [];
        const baseSymbol = gridTask?.baseAsset || gridTask?.baseAssert || null;
        const quoteSymbol = gridTask?.quoteAsset || gridTask?.quoteAssert || null;
        let baseLeg = baseSymbol ? findLegBySymbol(legs, baseSymbol) : null;
        let quoteLeg = quoteSymbol ? findLegBySymbol(legs, quoteSymbol) : null;
        if (!baseLeg && legs.length) {
            baseLeg = legs[0];
        }
        if ((!quoteLeg && legs.length > 1) || (quoteLeg && baseLeg && quoteLeg === baseLeg && legs.length > 1)) {
            quoteLeg = legs.find(leg => leg !== baseLeg) || quoteLeg;
        }
        const baseAvgPrice = baseLeg && Number.isFinite(baseLeg.avgPrice) && baseLeg.avgPrice > 0
            ? baseLeg.avgPrice
            : null;
        const quoteAvgPrice = quoteLeg && Number.isFinite(quoteLeg.avgPrice) && quoteLeg.avgPrice > 0
            ? quoteLeg.avgPrice
            : null;
        let averageCrossRate = null;
        let averageBuyRate = null;
        let averageSellRate = null;
        if (baseAvgPrice && quoteAvgPrice) {
            const rate = baseAvgPrice / quoteAvgPrice;
            averageCrossRate = rate;
            if (baseLeg?.side === 'BUY' && quoteLeg?.side === 'SELL') {
                averageBuyRate = rate;
            } else if (baseLeg?.side === 'SELL' && quoteLeg?.side === 'BUY') {
                averageSellRate = rate;
            }
        }
        return {
            ...arbitrage,
            symbolLegs: legs,
            baseLeg,
            quoteLeg,
            averageCrossRate,
            averageBuyRate,
            averageSellRate
        };
    }

    function mergeGridTasksWithStats(gridTasks, taskStats) {
        const statsById = new Map(taskStats.map(task => [task.taskId, task]));
        const used = new Set();
        const merged = gridTasks.map((gridTask, index) => {
            const stats = statsById.get(gridTask.id);
            if (stats) {
                used.add(gridTask.id);
                return {
                    ...stats,
                    gridTask,
                    hasOrders: stats.totalOrders > 0,
                    gridIndex: index
                };
            }
            return {
                ...createEmptyTaskStats(gridTask),
                gridIndex: index
            };
        });

        const leftovers = taskStats
            .filter(task => !used.has(task.taskId))
            .map(task => ({
                ...task,
                gridTask: null,
                hasOrders: task.totalOrders > 0,
                gridIndex: Number.POSITIVE_INFINITY
            }))
            .sort((a, b) => {
                const aTime = Number.isFinite(a.end) ? a.end : Number.isFinite(a.latestTrade) ? a.latestTrade : 0;
                const bTime = Number.isFinite(b.end) ? b.end : Number.isFinite(b.latestTrade) ? b.latestTrade : 0;
                if (bTime !== aTime) {
                    return bTime - aTime;
                }
                return a.taskId.localeCompare(b.taskId);
            });

        return [...merged, ...leftovers].map(item => {
            const {gridIndex, ...rest} = item;
            const assetStats = composeAssetStats(rest.symbolStats, rest.gridTask);
            const arbitrages = Array.isArray(rest.arbitrages)
                ? rest.arbitrages.map(arbitrage => enhanceArbitrageWithGrid(arbitrage, rest.gridTask))
                : [];
            let crossWeightedTotal = 0;
            let crossWeight = 0;
            let buyWeightedTotal = 0;
            let buyWeight = 0;
            let sellWeightedTotal = 0;
            let sellWeight = 0;
            arbitrages.forEach(arbitrage => {
                if (Number.isFinite(arbitrage.averageCrossRate) && Number.isFinite(arbitrage.matchedQty) && arbitrage.matchedQty > 0) {
                    crossWeightedTotal += arbitrage.averageCrossRate * arbitrage.matchedQty;
                    crossWeight += arbitrage.matchedQty;
                }
                if (Number.isFinite(arbitrage.averageBuyRate) && Number.isFinite(arbitrage.buyQty) && arbitrage.buyQty > 0) {
                    buyWeightedTotal += arbitrage.averageBuyRate * arbitrage.buyQty;
                    buyWeight += arbitrage.buyQty;
                }
                if (Number.isFinite(arbitrage.averageSellRate) && Number.isFinite(arbitrage.sellQty) && arbitrage.sellQty > 0) {
                    sellWeightedTotal += arbitrage.averageSellRate * arbitrage.sellQty;
                    sellWeight += arbitrage.sellQty;
                }
            });
            const averageCrossRate = crossWeight ? crossWeightedTotal / crossWeight : null;
            const averageBuyRate = buyWeight ? buyWeightedTotal / buyWeight : null;
            const averageSellRate = sellWeight ? sellWeightedTotal / sellWeight : null;
            return {
                ...rest,
                assetStats,
                arbitrages,
                averageCrossRate,
                averageBuyRate,
                averageSellRate
            };
        });
    }

    function determineDefaultTaskId(tasks) {
        if (!Array.isArray(tasks) || !tasks.length) {
            return null;
        }
        const withOrders = tasks.filter(task => task.totalOrders > 0);
        return (withOrders[0] || tasks[0]).taskId;
    }

    function getTaskById(taskId) {
        if (!taskId) {
            return null;
        }
        return dashboardState.tasks.find(task => task.taskId === taskId) || null;
    }

    function getOrdersByTaskId(taskId) {
        if (!taskId) {
            return [];
        }
        return dashboardState.orders.filter(order => order.taskId === taskId);
    }

    function populateTaskSelector(tasks, selectedTaskId) {
        const selector = document.getElementById('grid-task-selector');
        if (!selector) {
            return;
        }

        selector.innerHTML = '';

        if (!Array.isArray(tasks) || !tasks.length) {
            selector.disabled = true;
            const option = document.createElement('option');
            option.value = '';
            option.textContent = '暂无网格任务';
            selector.appendChild(option);
            selector.value = '';
            return;
        }

        selector.disabled = false;
        tasks.forEach(task => {
            const option = document.createElement('option');
            option.value = task.taskId;
            const pairText = task.gridTask
                ? [task.gridTask.baseAsset, task.gridTask.quoteAsset].filter(Boolean).join('/')
                : (task.symbols && task.symbols.length ? task.symbols.join('/') : '');
            option.textContent = pairText ? `${task.taskId} · ${pairText}` : task.taskId;
            selector.appendChild(option);
        });

        const fallbackId = determineDefaultTaskId(tasks);
        const targetValue = tasks.some(task => task.taskId === selectedTaskId)
            ? selectedTaskId
            : fallbackId;
        selector.value = targetValue || '';
    }

    function renderSelectedTaskOverview(task) {
        const container = document.getElementById('selected-task-overview');
        const emptyHint = document.getElementById('grid-task-empty');
        if (!container || !emptyHint) {
            return;
        }

        container.innerHTML = '';

        if (!task) {
            emptyHint.hidden = false;
            return;
        }

        emptyHint.hidden = true;
        const assetStats = Array.isArray(task.assetStats) ? task.assetStats : [];
        const hasRealized = Number.isFinite(task.realizedProfit);
        const hasFee = Number.isFinite(task.totalFee);
        const netProfit = hasRealized && hasFee ? task.realizedProfit - task.totalFee : null;
        const metrics = [
            {
                key: fieldKey('overview', task.taskId, 'realized-profit'),
                label: '累计已套利利润',
                value: task.realizedProfit,
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('overview', task.taskId, 'total-fee'),
                label: '累计手续费',
                value: task.totalFee,
                decimals: FEE_DECIMALS
            },
            {
                key: fieldKey('overview', task.taskId, 'net-profit'),
                label: '净利润（扣手续费）',
                value: netProfit,
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('overview', task.taskId, 'net-exposure-notional'),
                label: '未平仓名义（双边仓位差值）',
                value: task.netExposureNotional,
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('overview', task.taskId, 'average-buy-rate'),
                label: '平均买入汇率',
                value: task.averageBuyRate,
                decimals: 4
            },
            {
                key: fieldKey('overview', task.taskId, 'average-sell-rate'),
                label: '平均卖出汇率',
                value: task.averageSellRate,
                decimals: 4
            },
            {
                key: fieldKey('overview', task.taskId, 'maker-order-ratio'),
                label: 'Maker成交额占比',
                value: task.makerOrderRatio,
                decimals: 4,
                isPercent: true
            },
            {
                key: fieldKey('overview', task.taskId, 'maker-participation'),
                label: '平均Maker参与度',
                value: task.makerParticipation,
                decimals: 4,
                isPercent: true
            },
            {
                key: fieldKey('overview', task.taskId, 'arbitrage-count'),
                label: '套利次数',
                value: task.arbitrageCount,
                decimals: 0
            }
        ];

        const gridTask = task.gridTask || null;
        const pairText = gridTask
            ? [gridTask.baseAsset, gridTask.quoteAsset].filter(Boolean).join(' / ')
            : (task.symbols && task.symbols.length ? task.symbols.join(' / ') : '-');
        const statusLabel = gridTask ? formatGridStatus(gridTask.status) : '未知';
        const gridInfoParts = [];
        if (gridTask && Number.isFinite(gridTask.gridRate)) {
            gridInfoParts.push(`网格间距 ${formatPercent(gridTask.gridRate, 4)}`);
        }
        if (gridTask && Number.isFinite(gridTask.gridValue)) {
            gridInfoParts.push(`单格金额 ${formatNumber(gridTask.gridValue, 4)}$`);
        }
        const timeRange = `时间范围：${formatDate(task.start)} ~ ${formatDate(task.end)}`;

        container.innerHTML = `
            <div class="asset-overview">
                <div class="asset-overview-header">
                    <span>任务 <strong>${task.taskId}</strong></span>
                    <span>币对 <strong>${pairText || '-'}</strong></span>
                    <span>状态 <strong>${statusLabel}</strong></span>
                    ${gridInfoParts.length ? `<span>${gridInfoParts.join(' · ')}</span>` : ''}
                </div>
                <div class="asset-metrics-grid">
                    ${metrics.map(renderOverviewMetric).join('')}
                </div>
                ${
            assetStats.length
                ? `<div class="asset-card-grid">${assetStats.map(renderAssetCard).join('')}</div>`
                : '<p class="placeholder">暂无资产成交记录</p>'
        }
                <div class="asset-overview-footer">${timeRange}</div>
            </div>
        `;
    }

    function renderOverviewMetric(metric) {
        const label = metric.label || '-';
        const value = metric.value;
        const decimals = typeof metric.decimals === 'number' ? metric.decimals : DEFAULT_DECIMALS;
        const isProfit = Boolean(metric.isProfit);
        const isPercent = Boolean(metric.isPercent);
        const key = metric.key || fieldKey('overview', label);
        let displayValue = '-';
        if (isPercent) {
            displayValue = Number.isFinite(value) ? formatPercent(value, decimals) : '-';
        } else if (Number.isFinite(value)) {
            displayValue = formatNumber(value, decimals);
        }
        let valueClass = 'asset-metric-value';
        if (isProfit && Number.isFinite(value)) {
            valueClass += ` ${getProfitClass(value)}`;
        }
        return `
            <div class="asset-metric" data-field-key="${key}">
                <span class="asset-metric-label">${label}</span>
                <span class="${valueClass}">${displayValue}</span>
            </div>
        `;
    }

    function renderAssetCard(asset) {
        const metrics = [
            {
                key: fieldKey('asset', asset.symbol, 'total-buy-qty'),
                label: '总买入量',
                value: asset.buyQty,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'total-buy-notional'),
                label: '总买入金额',
                value: asset.buyNotional,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'avg-buy-price'),
                label: '平均买入价',
                value: asset.avgBuyPrice,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'total-sell-qty'),
                label: '总卖出量',
                value: asset.sellQty,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'total-sell-notional'),
                label: '总卖出金额',
                value: asset.sellNotional,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'avg-sell-price'),
                label: '平均卖出价',
                value: asset.avgSellPrice,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'price-spread'),
                label: '价差',
                value: asset.priceSpread,
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('asset', asset.symbol, 'matched-qty'),
                label: '已套利数量',
                value: asset.matchedQty,
                decimals: 4
            },
            {
                key: fieldKey('asset', asset.symbol, 'realized-profit'),
                label: '已套利利润',
                value: asset.realizedProfit,
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('asset', asset.symbol, 'total-fee'),
                label: '总手续费',
                value: asset.totalFee,
                decimals: FEE_DECIMALS
            },
            {
                key: fieldKey('asset', asset.symbol, 'open-qty'),
                label: '当前持仓数量',
                value: asset.openQty,
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('asset', asset.symbol, 'nominal-holding'),
                label: '当前名义持仓',
                value: computeNominalHolding(asset),
                decimals: 4,
                isProfit: true
            },
            {
                key: fieldKey('asset', asset.symbol, 'maker-order-ratio'),
                label: 'Maker成交额占比',
                value: asset.makerOrderRatio,
                decimals: 4,
                isPercent: true
            }
        ];
        const profitValue = Number.isFinite(asset.realizedProfit)
            ? formatNumber(asset.realizedProfit, 4)
            : '-';
        const profitClass = Number.isFinite(asset.realizedProfit)
            ? `asset-card-profit ${getProfitClass(asset.realizedProfit)}`
            : 'asset-card-profit profit-neutral';
        return `
            <div class="asset-card">
                <div class="asset-card-header">
                    <span class="asset-card-title">${asset.symbol || '-'}</span>
                    <span class="${profitClass}" data-field-key="${fieldKey('asset', asset.symbol, 'profit')}">${profitValue}</span>
                </div>
                <div class="asset-card-metrics">
                    ${metrics.map(metric => renderAssetMetric(asset, metric)).join('')}
                </div>
                <div class="asset-card-footer" data-field-key="${fieldKey('asset', asset.symbol, 'last-update')}">最新成交：${formatDate(asset.lastUpdate)}</div>
            </div>
        `;
    }

    function renderAssetMetric(asset, metric) {
        const label = metric.label || '-';
        const value = metric.value;
        const decimals = typeof metric.decimals === 'number' ? metric.decimals : 2;
        const isProfit = Boolean(metric.isProfit);
        const isPercent = Boolean(metric.isPercent);
        const key = metric.key || fieldKey('asset-metric', asset?.symbol || '-', label);
        let displayValue = '-';
        if (isPercent) {
            displayValue = Number.isFinite(value) ? formatPercent(value, decimals) : '-';
        } else if (Number.isFinite(value)) {
            displayValue = formatNumber(value, decimals);
        }
        let valueClass = 'asset-card-metric-value';
        if (isProfit && Number.isFinite(value)) {
            valueClass += ` ${getProfitClass(value)}`;
        }
        return `
            <div class="asset-card-metric" data-field-key="${key}">
                <span class="asset-card-metric-label">${label}</span>
                <span class="${valueClass}">${displayValue}</span>
            </div>
        `;
    }

    function computeNominalHolding(asset) {
        const quantity = Number.isFinite(asset.openQty) ? asset.openQty : null;
        const lastPrice = Number.isFinite(asset.lastPrice) ? asset.lastPrice : null;
        if (quantity !== null && lastPrice !== null) {
            return quantity * lastPrice;
        }
        if (Number.isFinite(asset.openNotional)) {
            return asset.openNotional;
        }
        return NaN;
    }

    function renderDashboard() {
        const taskId = dashboardState.selectedTaskId;
        const selectedTask = getTaskById(taskId);
        const filteredOrders = getOrdersByTaskId(taskId);

        renderSelectedTaskOverview(selectedTask);
        renderTaskHierarchy(dashboardState.tasks, taskId);
        renderTimeline(filteredOrders);
        updateSectionIndicators(taskId);
    }

    const GRID_STATUS_LABELS = {
        RUNNING: '运行中',
        ACTIVE: '运行中',
        PAUSED: '已暂停',
        IDLE: '待启动',
        STOPPED: '已停止',
        FINISHED: '已结束',
        COMPLETED: '已结束',
        ERROR: '异常',
        FAILED: '异常',
        WAITING: '待启动',
        UNKNOWN: '未知'
    };

    function formatGridStatus(status) {
        if (!status) {
            return GRID_STATUS_LABELS.UNKNOWN;
        }
        const normalized = String(status).toUpperCase();
        return GRID_STATUS_LABELS[normalized] || normalized;
    }

    function getStatusClass(status) {
        if (!status) {
            return 'status-unknown';
        }
        const normalized = String(status).toUpperCase();
        if (normalized === 'RUNNING' || normalized === 'ACTIVE') {
            return 'status-running';
        }
        if (normalized === 'PAUSED' || normalized === 'WAITING' || normalized === 'IDLE') {
            return 'status-idle';
        }
        if (normalized === 'STOPPED') {
            return 'status-stopped';
        }
        if (normalized === 'FINISHED' || normalized === 'COMPLETED') {
            return 'status-finished';
        }
        if (normalized === 'ERROR' || normalized === 'FAILED') {
            return 'status-error';
        }
        return 'status-unknown';
    }

    function formatBoolean(value) {
        if (value === undefined || value === null) {
            return '-';
        }
        return value ? '是' : '否';
    }

    function formatValueWithUnit(value, unit = '', decimals = DEFAULT_DECIMALS) {
        if (!Number.isFinite(value)) {
            return '-';
        }
        const formatted = formatNumber(value, decimals);
        return unit ? `${formatted} ${unit}` : formatted;
    }

    function hasRuntimeData(runtime) {
        if (!runtime || typeof runtime !== 'object') {
            return false;
        }
        return ['baseQty', 'quoteQty', 'buyPrice', 'sellPrice', 'lastTradePrice'].some(key => Number.isFinite(runtime[key]));
    }

    function renderConfigItem(label, value, key) {
        const dataAttr = key ? ` data-field-key="${key}"` : '';
        return `
            <div class="grid-config-item"${dataAttr}>
                <span class="config-label">${label}</span>
                <span class="config-value">${value}</span>
            </div>
        `;
    }

    function createGridConfig(gridTask) {
        if (!gridTask) {
            return '';
        }
        const pair = [gridTask.baseAsset, gridTask.quoteAsset].filter(Boolean).join(' / ') || '-';
        const sections = [];
        sections.push(`
            <div class="grid-config-section">
                <div class="grid-config-title">任务参数</div>
                <div class="grid-config-grid">
                    ${renderConfigItem('网格任务', gridTask.id, fieldKey('grid-task', gridTask.id, 'id'))}
                    ${renderConfigItem('基础资产', gridTask.baseAsset || '-', fieldKey('grid-task', gridTask.id, 'base-asset'))}
                    ${renderConfigItem('报价资产', gridTask.quoteAsset || '-', fieldKey('grid-task', gridTask.id, 'quote-asset'))}
                    ${renderConfigItem('标的组合', pair, fieldKey('grid-task', gridTask.id, 'pair'))}
                    ${renderConfigItem('起始价', formatNumber(gridTask.startPrice, 4), fieldKey('grid-task', gridTask.id, 'start-price'))}
                    ${renderConfigItem('网格间距', formatPercent(gridTask.gridRate, 4), fieldKey('grid-task', gridTask.id, 'grid-rate'))}
                    ${renderConfigItem('单格金额', formatValueWithUnit(gridTask.gridValue, 'USDT', 4), fieldKey('grid-task', gridTask.id, 'grid-value'))}
                    ${renderConfigItem('双向执行', formatBoolean(gridTask.doubled), fieldKey('grid-task', gridTask.id, 'doubled'))}
                    ${renderConfigItem('反向套利', formatBoolean(gridTask.reversed), fieldKey('grid-task', gridTask.id, 'reversed'))}
                </div>
            </div>
        `);

        if (hasRuntimeData(gridTask.runtime)) {
            const runtime = gridTask.runtime || {};
            sections.push(`
                <div class="grid-config-section">
                    <div class="grid-config-title">运行状态</div>
                    <div class="grid-config-grid">
                        ${renderConfigItem('base资产单格数量', formatNumber(runtime.baseQty, 4), fieldKey('grid-task', gridTask.id, 'runtime-baseqty'))}
                        ${renderConfigItem('quote资产单格数量', formatNumber(runtime.quoteQty, 4), fieldKey('grid-task', gridTask.id, 'runtime-quoteqty'))}
                        ${renderConfigItem('当前买入价', formatNumber(runtime.buyPrice, 4), fieldKey('grid-task', gridTask.id, 'runtime-buy-price'))}
                        ${renderConfigItem('当前卖出价', formatNumber(runtime.sellPrice, 4), fieldKey('grid-task', gridTask.id, 'runtime-sell-price'))}
                        ${renderConfigItem('最新成交价', formatNumber(runtime.lastTradePrice, 4), fieldKey('grid-task', gridTask.id, 'runtime-last-trade-price'))}
                    </div>
                </div>
            `);
        }

        return `<div class="grid-config">${sections.join('')}</div>`;
    }

    function updateSectionIndicators(taskId) {
        const text = taskId ? `当前任务：${taskId}` : '当前任务：-';
        const taskIndicator = document.getElementById('task-filter-indicator');
        const timelineIndicator = document.getElementById('timeline-filter-indicator');
        if (taskIndicator) {
            taskIndicator.textContent = text;
        }
        if (timelineIndicator) {
            timelineIndicator.textContent = text;
        }
    }

    function updateSelectedTaskId(taskId) {
        const tasks = dashboardState.tasks;
        if (!tasks.length) {
            dashboardState.selectedTaskId = null;
        } else {
            const exists = tasks.some(task => task.taskId === taskId);
            dashboardState.selectedTaskId = exists ? taskId : determineDefaultTaskId(tasks);
        }

        const selector = document.getElementById('grid-task-selector');
        if (selector) {
            const desiredValue = dashboardState.selectedTaskId || '';
            if (selector.value !== desiredValue) {
                selector.value = desiredValue;
            }
        }

        renderDashboard();
        applyFieldHighlights({skipAnimation: true});

        if (dashboardState.selectedTaskId) {
            requestAnimationFrame(() => {
                const target = document.querySelector(`details[data-task-id="${dashboardState.selectedTaskId}"]`);
                if (target) {
                    target.open = true;
                    target.scrollIntoView({behavior: 'smooth', block: 'start'});
                }
            });
        }
    }

    function renderTaskHierarchy(tasks, selectedTaskId) {
        const container = document.getElementById('task-hierarchy');
        const emptyHint = document.getElementById('task-empty');
        container.innerHTML = '';

        const existingTaskIds = new Set(tasks.map(task => task.taskId));
        const filtered = selectedTaskId ? tasks.filter(task => task.taskId === selectedTaskId) : tasks;

        if (!filtered.length) {
            emptyHint.hidden = false;
            return;
        }

        emptyHint.hidden = true;
        dashboardState.expandedTaskBlocks.forEach((_, taskId) => {
            if (!existingTaskIds.has(taskId)) {
                dashboardState.expandedTaskBlocks.delete(taskId);
                dashboardState.expandedArbitrages.delete(taskId);
            }
        });
        dashboardState.arbitragePage.forEach((_, taskId) => {
            if (!existingTaskIds.has(taskId)) {
                dashboardState.arbitragePage.delete(taskId);
            }
        });

        filtered.forEach((task, index) => {
            const details = document.createElement('details');
            details.className = 'task-block';
            details.dataset.taskId = task.taskId;
            const hasExpandedState = dashboardState.expandedTaskBlocks.has(task.taskId);
            const shouldOpenTask = hasExpandedState ? dashboardState.expandedTaskBlocks.get(task.taskId) : index === 0;
            details.open = Boolean(shouldOpenTask);
            dashboardState.expandedTaskBlocks.set(task.taskId, details.open);
            details.addEventListener('toggle', () => {
                dashboardState.expandedTaskBlocks.set(task.taskId, details.open);
            });

            const summary = document.createElement('summary');
            summary.innerHTML = createTaskSummary(task);
            details.appendChild(summary);

            const content = document.createElement('div');
            content.className = 'task-block-content';

            if (task.gridTask) {
                content.insertAdjacentHTML('beforeend', createGridConfig(task.gridTask));
            }

            if (task.arbitrages && task.arbitrages.length) {
                const table = document.createElement('table');
                table.className = 'arbitrage-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>批次ID</th>
                            <th>交易汇率</th>
                            <th>交易方向</th>
                            <th class="text-right">交易金额 (USDT)</th>
                            <th class="text-right">交易总手续费</th>
                            <th>批次状态</th>
                            <th>套利时间</th>
                        </tr>
                    </thead>
                `;
                const tbody = document.createElement('tbody');
                const totalPages = Math.max(1, Math.ceil(task.arbitrages.length / ARBITRAGE_PAGE_SIZE));
                let currentPage = dashboardState.arbitragePage.get(task.taskId) || 1;
                if (currentPage > totalPages) {
                    currentPage = totalPages;
                }
                if (currentPage < 1) {
                    currentPage = 1;
                }
                dashboardState.arbitragePage.set(task.taskId, currentPage);
                const startIndex = (currentPage - 1) * ARBITRAGE_PAGE_SIZE;
                const arbitrageRows = task.arbitrages.slice(startIndex, startIndex + ARBITRAGE_PAGE_SIZE);
                const columnCount = table.querySelector('thead tr').children.length || 1;
                let expandedBindId = dashboardState.expandedArbitrages.get(task.taskId) ?? null;
                const hasArbState = Boolean(expandedBindId && arbitrageRows.some(item => item.taskBindId === expandedBindId));
                arbitrageRows.forEach((arbitrage, index) => {
                    const summaryRow = document.createElement('tr');
                    summaryRow.className = 'arbitrage-summary-row';
                    summaryRow.innerHTML = createArbitrageSummaryCells(arbitrage, task);
                    summaryRow.tabIndex = 0;
                    summaryRow.setAttribute('role', 'button');
                    const shouldOpenArbitrage = hasArbState ? expandedBindId === arbitrage.taskBindId : index === 0;
                    summaryRow.setAttribute('aria-expanded', shouldOpenArbitrage ? 'true' : 'false');

                    const detailRow = document.createElement('tr');
                    detailRow.className = 'arbitrage-detail-row';
                    detailRow.hidden = !shouldOpenArbitrage;
                    const detailCell = document.createElement('td');
                    detailCell.colSpan = columnCount;
                    detailCell.innerHTML = createArbitrageDetail(arbitrage, task);
                    detailRow.appendChild(detailCell);
                    if (!hasArbState && shouldOpenArbitrage) {
                        dashboardState.expandedArbitrages.set(task.taskId, arbitrage.taskBindId);
                    }

                    summaryRow.addEventListener('click', () => {
                        toggleArbitrageDetail(task.taskId, arbitrage.taskBindId, summaryRow, detailRow, tbody);
                    });
                    summaryRow.addEventListener('keydown', event => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            toggleArbitrageDetail(task.taskId, arbitrage.taskBindId, summaryRow, detailRow, tbody);
                        }
                    });

                    tbody.appendChild(summaryRow);
                    tbody.appendChild(detailRow);
                });
                table.appendChild(tbody);
                content.appendChild(table);
                if (totalPages > 1) {
                    const pager = document.createElement('div');
                    pager.className = 'arbitrage-pagination';
                    pager.innerHTML = `
                        <button type="button" class="arbitrage-page-btn prev" ${currentPage === 1 ? 'disabled' : ''}>上一页</button>
                        <span class="arbitrage-page-indicator">第 ${currentPage} / ${totalPages} 页</span>
                        <button type="button" class="arbitrage-page-btn next" ${currentPage === totalPages ? 'disabled' : ''}>下一页</button>
                    `;
                    const prevBtn = pager.querySelector('.arbitrage-page-btn.prev');
                    const nextBtn = pager.querySelector('.arbitrage-page-btn.next');
                    if (prevBtn) {
                        prevBtn.addEventListener('click', () => {
                            changeArbitragePage(task.taskId, -1);
                        });
                    }
                    if (nextBtn) {
                        nextBtn.addEventListener('click', () => {
                            changeArbitragePage(task.taskId, 1);
                        });
                    }
                    content.appendChild(pager);
                }
            } else {
                dashboardState.expandedArbitrages.delete(task.taskId);
                dashboardState.arbitragePage.delete(task.taskId);
                const placeholder = document.createElement('p');
                placeholder.className = 'placeholder';
                placeholder.textContent = task.hasOrders
                    ? '暂无套利批次统计。'
                    : '暂无成交记录，等待订单数据。';
                content.appendChild(placeholder);
            }
            details.appendChild(content);
            container.appendChild(details);
        });
    }

    function createTaskSummary(task) {
        const runtime = task.gridTask && task.gridTask.runtime ? task.gridTask.runtime : {};

        const symbolsText = task.symbols.length ? task.symbols.join('、') : '-';
        const arbitrageSummary = `${formatNumber(task.arbitrageCount, 0)}（完成 ${formatNumber(task.completedCount, 0)} / 未平 ${formatNumber(task.openCount, 0)}）`;
        const latestTradedPrice = `${formatNumber(runtime.lastTradePrice, 4)}`;
        const nextBidPrice = `${formatNumber(runtime.buyPrice, 4)}`;
        const nextAskPrice = `${formatNumber(runtime.sellPrice, 4)}`;

        const timeRange = (Number.isFinite(task.start) || Number.isFinite(task.end))
            ? `${formatDate(task.start)} ~ ${formatDate(task.end)}`
            : '暂无成交时间';
        const statusBadge = task.gridTask
            ? `<span class="status-badge ${getStatusClass(task.gridTask.status)}">${formatGridStatus(task.gridTask.status)}</span>`
            : `<span class="status-badge status-unknown">未登记</span>`;

        const gridInfoChips = [];
        if (task.gridTask) {
            if (Number.isFinite(task.gridTask.gridRate)) {
                gridInfoChips.push(`网格间距 ${formatPercent(task.gridTask.gridRate, 4)}`);
            }
            if (Number.isFinite(task.gridTask.gridValue)) {
                gridInfoChips.push(`单格金额 ${formatValueWithUnit(task.gridTask.gridValue, 'USDT', 4)}`);
            }
            if (Number.isFinite(task.gridTask.startPrice)) {
                gridInfoChips.push(`启动汇率 ${formatValueWithUnit(task.gridTask.startPrice)} (base ${task.gridTask.startBaseP} / quote ${task.gridTask.startQuoteP})`);
            }
        }
        if (Number.isFinite(runtime.baseQty) || Number.isFinite(runtime.quoteQty)) {
            const base = Number.isFinite(runtime.baseQty) ? formatNumber(runtime.baseQty, 4) : '-';
            const quote = Number.isFinite(runtime.quoteQty) ? formatNumber(runtime.quoteQty, 4) : '-';
            gridInfoChips.push(`单格数量 base ${base} / quote ${quote}`);
        }
        if (Number.isFinite(runtime.buyPrice)) {
            // gridInfoChips.push(`下一买入汇率 ${formatNumber(runtime.buyPrice, 4)}`);
        }
        if (Number.isFinite(runtime.sellPrice)) {
            // gridInfoChips.push(`下一卖出汇率 ${formatNumber(runtime.sellPrice, 4)}`);
        }
        if (Number.isFinite(runtime.lastTradePrice)) {
            // gridInfoChips.push(`最新成交汇率 ${formatNumber(runtime.lastTradePrice, 4)}`);
        }
        const chipHtml = gridInfoChips.map(chip => `<span class="task-chip">${chip}</span>`).join('');

        const latestTradeTime = formatDate(task.latestTrade);
        const summaryItems = [
            {label: '套利批次', value: arbitrageSummary},
            {label: '最新成交汇率', value: latestTradedPrice},
            {label: '下一买汇率', value: nextBidPrice},
            {label: '下一卖汇率', value: nextAskPrice},
            {label: '最新成交时间', value: latestTradeTime},
            {label: '时间范围', value: timeRange}
        ];
        const summaryHtml = summaryItems.map(item => `
            <div class="task-summary-card" data-field-key="${fieldKey('task-summary', task.taskId, item.label)}">
                <span class="task-summary-label">${item.label}</span>
                <span class="task-summary-value">${item.value}</span>
            </div>
        `).join('');

        return `
            <div class="task-header">
                <div class="task-info">
                    <div class="task-title-row">
                        ${statusBadge}
                        <span class="task-title">${task.taskId}</span>
                    </div>
                    <div class="task-subtitle">币对：${symbolsText}</div>
                    ${chipHtml ? `<div class="task-chip-group">${chipHtml}</div>` : ''}
                </div>
                <div class="task-summary-panel">
                    ${summaryHtml}
                </div>
            </div>
        `;
    }

    function createArbitrageSummaryCells(arbitrage, task) {
        const totalFee = (Number.isFinite(arbitrage.baseLeg?.totalFee) ? arbitrage.baseLeg.totalFee : 0)
            + (Number.isFinite(arbitrage.quoteLeg?.totalFee) ? arbitrage.quoteLeg.totalFee : 0);
        const synthRate = Number.isFinite(arbitrage.synthPrice) ? formatNumber(arbitrage.synthPrice, 4) : '-';
        const baseDirection = arbitrage.baseLeg?.side === 'BUY' ? '买入' : arbitrage.baseLeg?.side === 'SELL' ? '卖出' : '-';
        const baseAmountValue = Number.isFinite(arbitrage.baseLeg?.notional)
            ? formatNumber(arbitrage.baseLeg.notional, 4)
            : '-';
        const totalFeeText = Number.isFinite(totalFee) ? formatNumber(totalFee, FEE_DECIMALS) : '-';
        const statusText = arbitrage.status || '-';
        const baseTimeStart = Number.isFinite(arbitrage.baseLeg?.earliest) ? formatDate(arbitrage.baseLeg.earliest) : formatDate(arbitrage.start);
        const baseTimeEnd = Number.isFinite(arbitrage.baseLeg?.latest) ? formatDate(arbitrage.baseLeg.latest) : formatDate(arbitrage.end);
        const timeLabel = `${baseTimeStart}<br><small>${baseTimeEnd}</small>`;
        return `
            <td class="arbitrage-id-cell">${arbitrage.taskBindId}</td>
            <td>${synthRate}</td>
            <td>${baseDirection}</td>
            <td class="text-right">${baseAmountValue}</td>
            <td class="text-right">${totalFeeText}</td>
            <td>${statusText}</td>
            <td>${timeLabel}</td>
        `;
    }

    function createArbitrageDetail(arbitrage, task) {
        const baseLabel = task?.gridTask?.baseAsset || task?.gridTask?.baseAssert || arbitrage.baseLeg?.symbol || 'Base';
        const quoteLabel = task?.gridTask?.quoteAsset || task?.gridTask?.quoteAssert || arbitrage.quoteLeg?.symbol || 'Quote';
        const baseOrders = renderArbitrageOrderRows(arbitrage.baseLeg, 'Base');
        const quoteOrders = renderArbitrageOrderRows(arbitrage.quoteLeg, 'Quote');
        return `
            <div class="arbitrage-detail">
                <div class="arbitrage-detail-legs">
                    <div class="arbitrage-orders-table-wrapper">
                        <table class="arbitrage-orders-table">
                            <thead>
                                <tr>
                                    <th>角色</th>
                                    <th>订单ID</th>
                                    <th>方向</th>
                                    <th>交易对</th>
                                    <th class="text-right">成交数量</th>
                                    <th class="text-right">成交价格</th>
                                    <th class="text-right">成交金额</th>
                                    <th class="text-right">手续费</th>
                                    <th class="text-right">Maker占比</th>
                                    <th class="text-right">订单状态</th>
                                    <th>成交时间</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${baseOrders}
                                ${quoteOrders}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
    }

    function translateOrderStatus(status) {
        switch (status) {
            case 'NEW':
                return '待成交';
            case 'FILLED':
                return '已成交';
            case 'CANCELED':
                return '已取消';
            default:
                return status || '-';
        }
    }

    function renderArbitrageOrderRows(leg, label) {
        if (!leg || !Array.isArray(leg.orders) || !leg.orders.length) {
            return `
                <tr>
                    <td>${label}</td>
                    <td colspan="10"><span class="placeholder">暂无订单</span></td>
                </tr>
            `;
        }
        const rows = leg.orders
            .slice()
            .sort((a, b) => a.updateTime - b.updateTime)
            .map(order => {
                const orderId = order.orderId || order.clientOrderId || '-';
                const maker = order.makerFeeRate
                    || (Number.isFinite(order.makerParticipation) ? formatPercent(order.makerParticipation, 4) : '-');
                return `
                    <tr>
                        <td>${label}</td>
                        <td>${orderId}</td>
                        <td>${order.side || '-'}</td>
                        <td>${order.symbol || '-'}</td>
                        <td class="text-right">${formatNumber(order.quantity, 4)}</td>
                        <td class="text-right">${formatNumber(order.price, 4)}</td>
                        <td class="text-right">${formatNumber(order.notional, 4)}</td>
                        <td class="text-right">${formatNumber(order.txFee, FEE_DECIMALS)}</td>
                        <td class="text-right">${maker}</td>
                        <td class="text-right">${translateOrderStatus(order.status)}</td>
                        <td>${formatDate(order.updateTime)}</td>
                    </tr>
                `;
            })
            .join('');
        return rows;
    }

    function renderLegSummaryLine(leg, label, symbolLabel) {
        if (!leg) {
            return '';
        }
        const direction = leg.side === 'BUY' ? '买入' : leg.side === 'SELL' ? '卖出' : '-';
        const quantity = Number.isFinite(leg.quantity) ? formatNumber(leg.quantity, 4) : '-';
        const avgPrice = Number.isFinite(leg.avgPrice) ? formatNumber(leg.avgPrice, 4) : '-';
        const notional = Number.isFinite(leg.notional) ? formatNumber(leg.notional, 4) : '-';
        const fee = Number.isFinite(leg.totalFee) ? formatNumber(leg.totalFee, FEE_DECIMALS) : '-';
        const maker = Number.isFinite(leg.makerOrderRatio) ? formatPercent(leg.makerOrderRatio, 4) : '-';
        const symbol = symbolLabel || leg.symbol || label;
        return `
            <div class="rate-line">${label} ${symbol} · ${direction} 数量 ${quantity} · 均价 ${avgPrice} · 金额 ${notional} USDT · 手续费 ${fee} · Maker ${maker}</div>
        `;
    }

    function toggleArbitrageDetail(taskId, arbitrageId, summaryRow, detailRow, tbody) {
        const isHidden = detailRow.hidden;
        const summaryRows = Array.from(tbody.querySelectorAll('tr.arbitrage-summary-row'));
        const detailRows = Array.from(tbody.querySelectorAll('tr.arbitrage-detail-row'));
        let openedBindId = null;
        detailRows.forEach((row, index) => {
            const summary = summaryRows[index];
            if (row === detailRow) {
                const shouldOpen = isHidden;
                row.hidden = !shouldOpen;
                summary.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
                if (shouldOpen) {
                    openedBindId = arbitrageId;
                }
            } else {
                row.hidden = true;
                summary.setAttribute('aria-expanded', 'false');
            }
        });
        if (taskId) {
            if (openedBindId) {
                dashboardState.expandedArbitrages.set(taskId, openedBindId);
            } else {
                dashboardState.expandedArbitrages.set(taskId, null);
            }
        }
    }

    function changeArbitragePage(taskId, delta) {
        if (!taskId || typeof delta !== 'number') {
            return;
        }
        const task = dashboardState.tasks.find(item => item.taskId === taskId);
        if (!task || !Array.isArray(task.arbitrages) || !task.arbitrages.length) {
            return;
        }
        const totalPages = Math.max(1, Math.ceil(task.arbitrages.length / ARBITRAGE_PAGE_SIZE));
        const currentPage = dashboardState.arbitragePage.get(taskId) || 1;
        const nextPage = Math.min(Math.max(currentPage + delta, 1), totalPages);
        if (nextPage === currentPage) {
            return;
        }
        dashboardState.arbitragePage.set(taskId, nextPage);
        dashboardState.expandedArbitrages.delete(taskId);
        renderDashboard();
    }

    function renderArbitrageRates(arbitrage, baseLabel, quoteLabel) {
        const lines = [];
        if (Number.isFinite(arbitrage.averageBuyRate)) {
            lines.push(`买入 ${baseLabel}/${quoteLabel} ${formatNumber(arbitrage.averageBuyRate, 4)}`);
        }
        if (Number.isFinite(arbitrage.averageSellRate)) {
            lines.push(`卖出 ${baseLabel}/${quoteLabel} ${formatNumber(arbitrage.averageSellRate, 4)}`);
        }
        if (!lines.length && Number.isFinite(arbitrage.averageCrossRate)) {
            lines.push(`平均 ${baseLabel}/${quoteLabel} ${formatNumber(arbitrage.averageCrossRate, 4)}`);
        }
        if (Number.isFinite(arbitrage.synthPrice)) {
            lines.push(`合成 ${formatNumber(arbitrage.synthPrice, 4)}`);
        }
        if (!lines.length) {
            return '<span class="placeholder">-</span>';
        }
        return lines.map(line => `<div class="rate-line">${line}</div>`).join('');
    }

    function determineArbitrageStatus(arbitrage) {
        const buyOrders = Array.isArray(arbitrage.buyOrders) ? arbitrage.buyOrders : [];
        const sellOrders = Array.isArray(arbitrage.sellOrders) ? arbitrage.sellOrders : [];
        const allOrders = buyOrders.concat(sellOrders).filter(Boolean);
        if (allOrders.some(order => order.status === 'CANCELED')) {
            return '部分完成';
        }
        const buyFilled = buyOrders.some(order => order.status === 'FILLED');
        const sellFilled = sellOrders.some(order => order.status === 'FILLED');
        if (buyFilled && sellFilled) {
            return '已完成';
        }
        if (buyFilled) {
            return '待卖出';
        }
        if (sellFilled) {
            return '待买入';
        }
        return '待交易';
    }

    function getOrderKey(order) {
        if (!order || typeof order !== 'object') {
            return null;
        }
        const preferred = order.orderId || order.clientOrderId;
        if (preferred) {
            return String(preferred);
        }
        const parts = [
            order.taskBindId,
            order.symbol,
            order.side,
            Number.isFinite(order.updateTime) ? order.updateTime : '',
            Number.isFinite(order.price) ? order.price : '',
            Number.isFinite(order.quantity) ? order.quantity : ''
        ];
        const fallback = parts.filter(part => part !== undefined && part !== null && part !== '').join('|');
        return fallback || null;
    }

    function renderTimeline(orders) {
        const tbody = document.getElementById('timeline-table');
        const emptyHint = document.getElementById('timeline-empty');
        tbody.innerHTML = '';

        if (!orders.length) {
            emptyHint.hidden = false;
            return;
        }

        emptyHint.hidden = true;
        const rawNewKeys = dashboardState.lastNewOrderKeys instanceof Set
            ? new Set(dashboardState.lastNewOrderKeys)
            : new Set();
        orders.slice().reverse().slice(0, 10).forEach(order => {
            const orderIdDisplay = order.orderId || order.clientOrderId || '-';
            const tr = document.createElement('tr');
            const orderKey = getOrderKey(order);
            tr.innerHTML = `
                <td>${order.symbol}</td>
                <td>${orderIdDisplay}</td>
                <td><span class="badge ${order.side === 'BUY' ? 'badge-buy' : 'badge-sell'}">${order.side}</span></td>
                <td class="text-right">${formatNumber(order.quantity, 4)}</td>
                <td class="text-right">${formatNumber(order.price, 4)}</td>
                <td class="text-right">${formatNumber(order.notional, 4)}</td>
                <td class="text-right">${formatNumber(order.txFee, FEE_DECIMALS)}</td>
                <td>${order.makerFeeRate || formatPercent(order.makerParticipation, 4)}</td>
                <td>${order.status || '-'}</td>
                <td>${formatDate(order.updateTime)}</td>
                <td>${order.taskBindId || '-'}</td>
            `;
            if (orderKey && rawNewKeys.has(orderKey)) {
                tr.classList.add('timeline-row-highlight');
                rawNewKeys.delete(orderKey);
                window.setTimeout(() => {
                    tr.classList.remove('timeline-row-highlight');
                }, 1500);
            }
            tbody.appendChild(tr);
        });
        dashboardState.lastNewOrderKeys = rawNewKeys;
    }

    function formatNumber(value, decimals = DEFAULT_DECIMALS) {
        if (!Number.isFinite(value)) {
            return '-';
        }
        const precision = Number.isFinite(decimals) ? decimals : DEFAULT_DECIMALS;
        return value.toLocaleString('en-US', {
            minimumFractionDigits: precision,
            maximumFractionDigits: precision
        });
    }

    function formatPercent(value, decimals = DEFAULT_DECIMALS) {
        if (!Number.isFinite(value)) {
            return '-';
        }
        return `${formatNumber(value * 100, decimals)}%`;
    }

    function formatDate(timestamp) {
        if (!Number.isFinite(timestamp) || timestamp <= 0) {
            return '-';
        }
        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) {
            return '-';
        }
        const yyyy = date.getFullYear();
        const mm = String(date.getMonth() + 1).padStart(2, '0');
        const dd = String(date.getDate()).padStart(2, '0');
        const hh = String(date.getHours()).padStart(2, '0');
        const min = String(date.getMinutes()).padStart(2, '0');
        const ss = String(date.getSeconds()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd} ${hh}:${min}:${ss}`;
    }

    function setSourceStatus(text) {
        const metaEl = document.getElementById('source-meta');
        if (metaEl) {
            metaEl.textContent = text;
        }
    }

    function updateMeta(text) {
        setSourceStatus(text);
        const lastRefreshEl = document.getElementById('last-refresh');
        if (lastRefreshEl) {
            lastRefreshEl.textContent = `最后更新：${formatDate(Date.now())}`;
        }
    }

    function resetError() {
        const errorEl = document.getElementById('error-message');
        if (errorEl) {
            errorEl.hidden = true;
            errorEl.textContent = '';
        }
    }

    function showError(message) {
        const errorEl = document.getElementById('error-message');
        if (errorEl) {
            errorEl.textContent = message;
            errorEl.hidden = false;
        }
    }

    function getProfitClass(value) {
        if (!Number.isFinite(value) || Math.abs(value) < 1e-12) {
            return 'profit-neutral';
        }
        return value > 0 ? 'profit-positive' : 'profit-negative';
    }

    function triggerFieldHighlight(element) {
        if (!element) {
            return;
        }
        element.classList.remove('data-field-highlight');
        void element.offsetWidth;
        element.classList.add('data-field-highlight');
        window.setTimeout(() => {
            element.classList.remove('data-field-highlight');
        }, 1200);
    }

    function applyFieldHighlights(options = {}) {
        const {skipAnimation = false} = options;
        const nextSnapshot = new Map();
        document.querySelectorAll('[data-field-key]').forEach(element => {
            const key = element.getAttribute('data-field-key');
            if (!key) {
                return;
            }
            const value = (element.textContent || '').replace(/\s+/g, ' ').trim();
            const previousValue = dashboardState.fieldSnapshot.get(key);
            nextSnapshot.set(key, value);
            if (previousValue !== undefined && previousValue !== value) {
                if (!skipAnimation) {
                    triggerFieldHighlight(element);
                }
                handleFieldChange(key, previousValue, value, element);
            }
        });
        dashboardState.fieldSnapshot = nextSnapshot;
    }

    function normalizeKeySegment(part) {
        if (part === undefined || part === null) {
            return '';
        }
        const raw = String(part).trim();
        if (!raw) {
            return '';
        }
        const ascii = raw
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        if (ascii) {
            return ascii;
        }
        let hash = 0;
        for (let i = 0; i < raw.length; i += 1) {
            hash = ((hash << 5) - hash) + raw.charCodeAt(i);
            hash |= 0;
        }
        return `h${Math.abs(hash)}`;
    }

    function fieldKey(...parts) {
        const normalized = parts
            .map(normalizeKeySegment)
            .filter(Boolean);
        return normalized.length ? normalized.join('__') : 'field';
    }

    function handleFieldChange(key, previousValue, nextValue, element) {
        if (!isRuntimeFieldKey(key)) {
            return;
        }
        const valueElement = element.querySelector('.config-value');
        const currentValueText = valueElement ? valueElement.textContent.trim() : nextValue;
        const previousNumeric = extractNumericValue(previousValue);
        const nextNumeric = extractNumericValue(currentValueText);
        const runtimeMatch = key.match(/runtime-(buy-price|sell-price|last-trade-price)$/);
        const runtimeField = runtimeMatch ? runtimeMatch[1] : null;
        const taskDetails = element.closest('[data-task-id]');
        const taskId = taskDetails ? taskDetails.dataset.taskId : null;
        document.dispatchEvent(new CustomEvent('grid-runtime-field-change', {
            detail: {
                key,
                taskId,
                field: runtimeField,
                previousText: previousValue,
                nextText: currentValueText,
                previousValue: previousNumeric,
                nextValue: nextNumeric,
                element
            }
        }));
    }

    function isRuntimeFieldKey(key) {
        if (typeof key !== 'string') {
            return false;
        }
        return /runtime-(buy-price|sell-price|last-trade-price)$/.test(key);
    }

    function extractNumericValue(text) {
        if (typeof text !== 'string') {
            return null;
        }
        const match = text.match(/-?\d+(?:\.\d+)?/g);
        if (!match || !match.length) {
            return null;
        }
        const parsed = Number(match[match.length - 1]);
        return Number.isFinite(parsed) ? parsed : null;
    }

    function startAutoRefresh() {
        stopAutoRefresh();
        dashboardState.refreshTimerId = window.setInterval(() => {
            refreshData({silent: true});
        }, 5000);
    }

    function stopAutoRefresh() {
        if (dashboardState.refreshTimerId !== null) {
            clearInterval(dashboardState.refreshTimerId);
            dashboardState.refreshTimerId = null;
        }
    }

    async function refreshData(options = {}) {
        const {initial = false, silent = false} = options;
        if (dashboardState.isRefreshing) {
            return;
        }
        dashboardState.isRefreshing = true;

        if (initial || !silent) {
            setSourceStatus('正在加载网格任务与订单数据...');
        }

        resetError();

        try {
            const [gridResult, orderResult] = await Promise.allSettled([
                loadGridTasks(),
                loadOrders()
            ]);

            let normalizedGridTasks = Array.isArray(dashboardState.gridTasks)
                ? [...dashboardState.gridTasks]
                : [];
            if (gridResult.status === 'fulfilled') {
                const rawTasks = Array.isArray(gridResult.value) ? gridResult.value : [];
                normalizedGridTasks = normalizeGridTasks(rawTasks);
            } else {
                const error = gridResult.reason instanceof Error ? gridResult.reason.message : '加载网格任务数据失败';
                showError(error);
                if (!dashboardState.gridTasks.length) {
                    normalizedGridTasks = [];
                }
            }

            let normalizedOrders = Array.isArray(dashboardState.orders)
                ? [...dashboardState.orders]
                : [];
            if (orderResult.status === 'fulfilled') {
                const payload = orderResult.value || {};
                normalizedOrders = normalizeOrders(payload.orders || []);
                normalizedOrders.sort((a, b) => a.updateTime - b.updateTime);
            } else {
                const error = orderResult.reason instanceof Error ? orderResult.reason.message : '加载订单数据失败';
                showError(error);
                if (!dashboardState.orders.length) {
                    normalizedOrders = [];
                }
            }

            const previousOrderKeys = dashboardState.orderKeySnapshot instanceof Set
                ? dashboardState.orderKeySnapshot
                : new Set();
            const nextOrderKeys = new Set();
            const newOrderKeys = new Set();
            normalizedOrders.forEach(order => {
                const key = getOrderKey(order);
                if (!key) {
                    return;
                }
                nextOrderKeys.add(key);
                if (previousOrderKeys.size > 0 && !previousOrderKeys.has(key)) {
                    newOrderKeys.add(key);
                }
            });

            const taskHierarchy = buildTaskHierarchy(normalizedOrders);
            const mergedTasks = mergeGridTasksWithStats(normalizedGridTasks, taskHierarchy);

            const previousSelectedTaskId = dashboardState.selectedTaskId;
            const hasPreviousTask = previousSelectedTaskId
                && mergedTasks.some(task => task.taskId === previousSelectedTaskId);

            dashboardState.orders = normalizedOrders;
            dashboardState.tasks = mergedTasks;
            dashboardState.gridTasks = normalizedGridTasks;
            dashboardState.selectedTaskId = hasPreviousTask
                ? previousSelectedTaskId
                : determineDefaultTaskId(mergedTasks);
            dashboardState.orderKeySnapshot = nextOrderKeys;
            dashboardState.lastNewOrderKeys = newOrderKeys;

            populateTaskSelector(mergedTasks, dashboardState.selectedTaskId);
            renderDashboard();
            applyFieldHighlights({
                skipAnimation: initial && dashboardState.fieldSnapshot.size === 0
            });

            const gridMeta = `${normalizedGridTasks.length} 个网格任务（../grid/data/grid_tasks.json）`;
            const orderMeta = normalizedOrders.length
                ? `${normalizedOrders.length} 条订单（../grid/data/orders.json）`
                : '暂无订单数据';
            updateMeta(`数据源：${gridMeta} · ${orderMeta}`);
        } catch (error) {
            showError(error instanceof Error ? error.message : String(error));
        } finally {
            dashboardState.isRefreshing = false;
        }
    }

    async function init() {
        await refreshData({initial: true, silent: false});
        startAutoRefresh();
    }

    init();
</script>
</body>
</html>
